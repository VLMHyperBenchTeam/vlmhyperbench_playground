# Задача 10: Рефакторинг Оркестратора (Async & Parallel)

## Цель
Обновить `BenchmarkOrchestrator` для поддержки параллельного выполнения задач на нескольких воркерах (GPU), асинхронного управления жизненным циклом контейнеров и интеграции с новой событийной моделью.

## Контекст
Текущая реализация (`benchmark_orchestrator.py`) работает синхронно и последовательно: запускает один контейнер, ждет завершения (через `container.attach`), потом следующий. Это неэффективно при наличии нескольких GPU или необходимости запускать независимые этапы (например, Eval для завершившегося Inference параллельно с Inference следующей модели).

## Подзадачи

1.  **Asyncio Loop**:
    *   Переписать методы `run_scheduler` и `benchmark_run` на `async/await`.
    *   Использовать `aiohttp` или асинхронный Docker клиент (`aiodocker`) для взаимодействия с Docker Engine.

2.  **Worker Pool & Resource Management**:
    *   Реализовать класс `ResourceManager`, отслеживающий доступные GPU.
    *   Логика распределения задач: если есть свободный GPU -> запускаем Inference Stage. Evaluation Stage (CPU) может запускаться параллельно без ограничений GPU.

3.  **Event Bus Integration**:
    *   Вместо `print()` использовать систему событий.
    *   Оркестратор должен отправлять события (`TASK_STARTED`, `TASK_COMPLETED`, `TASK_FAILED`, `LOG_UPDATE`) в Backend (через Redis/ZMQ или HTTP Webhook), чтобы UI мог обновляться в реальном времени.

4.  **Task Graph (DAG)**:
    *   Представлять бенчмарк как граф зависимостей:
        *   `Job A (Inference)` -> `Job B (Eval)` -> `Job C (Report)`.
    *   Запускать задачи по мере готовности зависимостей.

5.  **Fault Tolerance**:
    *   Обработка падения контейнеров.
    *   Возможность перезапуска упавшей задачи без перезапуска всего бенчмарка.

## Ожидаемый результат (ВЫПОЛНЕНО)
*   **Async & Parallel**: Оркестратор может запускать N контейнеров параллельно (где N = кол-во GPU). Реализован `ResourceManager` для управления очередью GPU.
*   **Event Bus**: UI получает живые обновления статусов через асинхронную шину событий (`EventBus`).
*   **Non-blocking**: Код оркестратора не блокируется ожиданием завершения контейнера благодаря использованию `aiodocker` и `asyncio`.
*   **Task DAG**: Реализован граф задач, позволяющий запускать этапы Evaluation сразу после готовности результатов Inference для конкретной модели.

## Реализация
Код вынесен в отдельный пакет `packages/orchestrator_core/`:
- `resource_manager.py`: Учет GPU.
- `task_graph.py`: Управление зависимостями (DAG).
- `event_bus.py`: Стриминг событий.
- `orchestrator.py`: Асинхронный планировщик.
- `tests/`: Юнит-тесты для ключевых компонентов.