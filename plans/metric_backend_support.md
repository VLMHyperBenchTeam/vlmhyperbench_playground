# Архитектурный план: Поддержка Backend (Framework) в Metric Registry

## 1. Проблема и Контекст
В экосистеме оценки VLM существуют различные библиотеки (например, `EvalScope`, `LightEval`, `native` реализации), которые могут содержать реализации одних и тех же метрик (например, ANLS, CIDEr, Accuracy). Пользователю необходимо иметь возможность явно указывать, какую именно реализацию (backend) использовать для расчета, чтобы обеспечить воспроизводимость или сравнение результатов.

## 2. Предлагаемые изменения

### 2.1. Структура Реестра (`MetricRegistry`)
Текущая структура: `{name: {version: cls}}`
Новая структура: `{name: {backend: {version: cls}}}`

Это позволит хранить несколько реализаций одной метрики под разными именами бэкендов.
По умолчанию бэкенд будет называться `native`.

### 2.2. Расширение декоратора `@register_metric`
Добавить параметр `backend`:
```python
@register_metric(name="anls", version="1.0.0", backend="evalscope")
class EvalScopeANLS(BaseMetric):
    ...
```

### 2.3. Логика поиска метрики (`MetricRegistry.get`)
Метод `get` должен принимать `backend` и `version`.
Алгоритм выбора:
1. Если `backend` указан: ищем строго в этом бэкенде.
2. Если `backend` НЕ указан:
   - Ищем в `native`.
   - Если в `native` нет, берем первый попавшийся бэкенд (или бросаем исключение, если их несколько и выбор неоднозначен).
3. Версия выбирается аналогично (конкретная или последняя).

### 2.4. Динамическое обнаружение (Discovery)
Для поддержки сторонних пакетов без их явного импорта в ядро, будем использовать `importlib.metadata.entry_points`.
Группа: `vlmhyperbench.metrics`

Пакеты-плагины в своем `pyproject.toml` смогут указывать:
```toml
[project.entry-points."vlmhyperbench.metrics"]
evalscope_metrics = "evalscope_plugin.metrics:register_all"
```

Реестр при инициализации (или по требованию) будет вызывать эти точки входа для саморегистрации плагинов.

### 2.5. Изоляция и управление зависимостями (Backend Isolation)
Поскольку разные бэкенды (например, `native` и `evalscope`) могут иметь конфликтующие зависимости, расчет метрик должен поддерживать изоляцию:
1.  **Группировка**: Оркестратор группирует запрошенные метрики по бэкендам.
2.  **Многоэтапная Оценка**: Для каждого бэкенда запускается отдельная сессия (контейнер), в которую устанавливаются специфичные для него зависимости.
3.  **Слияние**: Результаты из разных контейнеров объединяются в финальный отчет.

## 3. План реализации

1. **Модификация `MetricRegistry`**:
   - Изменить внутренний словарь `_metrics` на иерархический: `{name: {backend: {version: cls}}}`.
   - Обновить метод `register` для поддержки параметров `backend` и `dependencies`.
   - Обновить метод `get` с логикой выбора бэкенда по умолчанию (`native`).

2. **Обновление `MetricEvaluator`**:
   - Добавить фильтрацию метрик по активному бэкенду.
   - Поддержать передачу `backend` в конфигурации.

3. **Реализация Discovery**:
   - Добавить метод `discover_plugins()` в реестр, использующий `importlib.metadata`.

4. **Тестирование**:
   - Тест на регистрацию двух метрик с одинаковым именем, но разными бэкендами.
   - Тест на выбор бэкенда по умолчанию.
   - Тест на динамическую загрузку (mock entry points).

## 4. Mermaid Диаграмма

```mermaid
graph TD
    subgraph Registry
        R[MetricRegistry] --> M1[Metric: anls]
        M1 --> B1[Backend: native]
        M1 --> B2[Backend: evalscope]
        B1 --> V1[v1.0.0]
        B2 --> V2[v1.1.0]
    end
    
    subgraph Discovery
        EP[Entry Points] --> |load| P[Plugin Package]
        P --> |call| R
    end
    
    ME[MetricEvaluator] --> |get name=anls, backend=evalscope| R
    R --> |returns| cls[EvalScopeANLS]