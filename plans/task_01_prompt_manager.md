# Задача 1: Реализация Prompt Manager

## Цель
Создать модуль `PromptManager`, который будет отвечать за выбор и рендеринг промптов для каждого элемента датасета, основываясь на его метаданных и конфигурации запуска.

## Контекст
См. [ADR-009: Стратегия управления промптами](../docs_site/docs/architecture/adr/009-prompt-management.md).
Текущая реализация жестко привязывает промпты к датасету или передает один промпт на весь прогон. Нам нужна гибкость для работы с разнородными документами (паспорта, чеки и т.д.) в рамках одного датасета.

## Подзадачи

1.  **Расширить пакет `prompt_handler`**:
    *   Добавить класс `PromptResolver` в `packages/prompt_handler/prompt_handler/resolver.py`.
    *   Реализовать логику выбора промпта:
        *   `Override`: Проверка наличия `fixed_prompt` в конфиге.
        *   `Mapping`: Поиск промпта по `doc_type` в `prompt_collection`.
        *   `Fallback`: Использование дефолтного значения.

2.  **Обновить формат конфигурации**:
    *   Определить структуру JSON для `prompt_collection` (маппинг `doc_type` -> `prompt_template`).
    *   Добавить валидацию конфигурации (Pydantic модель).

3.  **Интеграция с рендерером**:
    *   Использовать существующий `render_prompt` для подстановки переменных в выбранный шаблон.

4.  **Тестирование**:
    *   Написать юнит-тесты для `PromptResolver`.
    *   Проверить разрешение конфликтов (когда есть и override, и mapping).

## Ожидаемый результат ✅ ВЫПОЛНЕНО
*   Модуль `prompt_manager` поддерживает класс `PromptResolver`.
*   Можно загрузить коллекцию промптов из JSON файла через `PromptManager.from_json`.
*   Метод `get_prompts(item_metadata, overrides, context)` возвращает словарь с готовыми строками промптов (`system_prompt`, `user_prompt`).
*   Реализована иерархия приоритетов: Fixed Overrides > Mapping (doc_type) > Defaults.
*   Поддерживается рендеринг шаблонов через Jinja2.