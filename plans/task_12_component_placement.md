# Задача 12: Размещение Компонентов (Component Placement Strategy)

## Цель
Определить физическое расположение компонентов (где они запускаются) для обеспечения изоляции зависимостей и безопасности управления Docker-контейнерами.

## Контекст
У нас есть компоненты с разными требованиями к привилегиям и зависимостям:
*   **Orchestrator**: Должен уметь запускать Docker-контейнеры (требует доступа к Docker Socket).
*   **Backend**: Предоставляет API для UI, хранит состояние в БД.
*   **Web UI**: Статика (React).
*   **Inference/Eval/Report**: Тяжелые задачи, требующие изоляции зависимостей.

Исследование (Tavily) подтверждает, что управление Docker-контейнерами лучше всего осуществлять с хоста (Docker Host Layer), чтобы избежать проблем с безопасностью и сложностью Docker-in-Docker (DinD). При этом Backend, как stateless сервис, может жить в контейнере, но ему нужен канал связи с Оркестратором.

## Стратегия Размещения

### 1. Host Layer (Orchestrator Service)
**Роль**: Управление ресурсами и запуск контейнеров.
**Компонент**: `-hyperbench-orchestrator-service` (Systemd unit или просто фоновый процесс).
**Почему на хосте**:
*   Прямой доступ к `/var/run/docker.sock` без проброса в контейнер (безопасность).
*   Прямой доступ к GPU драйверам для мониторинга (`nvidia-smi`).
*   Управление локальными директориями для монтирования томов.

### 2. Container Layer (Management Plane)
**Роль**: Бизнес-логика, API, Хранение состояния.
**Контейнер**: `hyperbench-backend`
*   **Backend (FastAPI)**: Принимает запросы от UI.
*   **Database (SQLite/Postgres)**: Хранит метаданные экспериментов.
*   **Web UI (Nginx/Uvicorn)**: Раздает статику фронтенда.

**Взаимодействие**: Backend общается с Оркестратором (на хосте) через локальный HTTP API (например, `localhost:8001`) или через очередь сообщений (Redis), если она поднята в контейнере.
*Решение*: Для упрощения на старте, **Backend и Оркестратор могут быть объединены в один сервис на хосте**, но запускаться в разных виртуальных окружениях (venv). Это упростит коммуникацию.
*Альтернатива (выбранная)*: **Backend в контейнере, Оркестратор на хосте**. Связь через HTTP. Это позволит изолировать зависимости бэкенда (SQLAlchemy, Pydantic) от системных зависимостей оркестратора (Docker SDK).

### 3. Execution Layer (Ephemeral Containers)
**Роль**: Выполнение конкретных задач.
**Контейнеры**:
*   `vlm-inference-gpu`: Модель + API Wrapper.
*   `vlm-eval-cpu`: Метрики.
*   `vlm-report-cpu`: Генерация отчетов.

## Итоговая схема

1.  **Host Machine**:
    *   Запущен `vlm-orchestrator` (Python скрипт, слушает порт 8001).
    *   Имеет доступ к Docker Engine.

2.  **Docker Network (`vlm-net`)**:
    *   `vlm-backend` (FastAPI, порт 8000).
    *   `vlm-ui` (React, порт 3000).
    *   `redis` (Очередь задач / Event Bus).

3.  **Поток запуска**:
    1.  Пользователь (UI) -> `vlm-backend` (POST /run).
    2.  `vlm-backend` кладет задачу в Redis или вызывает `vlm-orchestrator` (http://host.docker.internal:8001).
    3.  `vlm-orchestrator` читает задачу, скачивает данные (Data Layer) и делает `docker run ...`.

## Ожидаемый результат (ВЫПОЛНЕНО)
*   **Host Layer**: Оркестратор (`orchestrator_core`) реализован как сервис для запуска на хосте, что обеспечивает безопасный доступ к Docker socket и GPU.
*   **Container Layer**: Уточнены интерфейсы для взаимодействия с Management Plane (Backend) через EventBus и HTTP.
*   **Изоляция**: Четкое разделение ответственности между управляющим слоем (Host) и исполнительным слоем (Ephemeral Containers).