# Анализ механизмов расширяемости: Инференс vs Метрики

## 1. Текущие механизмы (Inference & Plugins)

Проанализировав задачи 13, 15, 02 и 14, можно выделить следующие подходы:

*   **Inference Layer (API Wrapper)**: Использует динамическую загрузку адаптеров (`vllm-adapter`, `deepseek-adapter`) через `importlib`. Адаптеры являются отдельными пакетами. Выбор адаптера происходит на основе типа модели.
*   **Dependency Injection (Task 13)**: Абстрагирует установку пакетов (pip/uv/conda) в контейнеры. Это фундамент для работы плагинов.
*   **Dataset Factory (Task 14)**: Использует `DatasetRegistry` с декоратором `@register` и поддерживает динамический импорт по полному пути (`my_pkg.MyIterator`).
*   **Dynamic Plugin System (Task 15)**: Позволяет пользователю указывать `custom_packages` в YAML, которые оркестратор устанавливает в контейнер.

## 2. Сравнение и Унификация

### Сходства:
1.  **Динамический импорт**: Все системы (Inference, Datasets, Metrics) используют `importlib` для загрузки кода по строковому пути.
2.  **Реестры**: И метрики, и датасеты используют паттерн Registry с декораторами для регистрации "из коробки".
3.  **Модульность**: Все компоненты являются независимыми Python-пакетами.

### Различия в выборе реализации:
*   **Инференс**: Выбор адаптера (backend) жестко привязан к *типу модели*. Пользователь выбирает модель, а система подбирает совместимый адаптер.
*   **Метрики**: Для одной и той же метрики (например, "accuracy") может существовать несколько *равнозначных* реализаций (backends), и пользователь должен иметь возможность выбрать любую из них.

## 3. Выводы по унификации

Унификация логики работы реестров (Datasets, Metrics) — хорошая идея. Мы можем использовать единый подход к:
1.  **Dot-notation загрузке** (`pkg.Class`).
2.  **Декораторам регистрации**.
3.  **Discovery через entry points** (хотя Task 15 предлагает явную конфигурацию, entry points полезны для "автоматических" плагинов).

Однако, **выбор бэкенда** для метрик — это специфичная задача, которая ближе к выбору "движка". 

### Предлагаемая концепция "Metric Backend":
Вместо того чтобы просто добавлять поле `backend` в реестр, мы можем рассматривать это как **Namespace**.

Конфигурация в YAML:
```yaml
metrics:
  - name: "anls"
    backend: "evalscope" # Явный выбор
  - name: "cer"
    # backend по умолчанию (native)
```

## 4. Резюме для Metric Registry

Стоит придерживаться плана расширения `MetricRegistry` для поддержки `backend`, так как это дает необходимую гибкость. 
Унификация с инференсом возможна на уровне **инфраструктуры загрузки пакетов** (которую уже решает `DependencyInjector`), но логика выбора (lookup) в реестре метрик должна поддерживать иерархию `Name -> Backend -> Version`.

### План действий:
1.  Доработать `MetricRegistry` для хранения `backend`.
2.  Обеспечить совместимость с `custom_packages` (чтобы установленные пакеты могли регистрировать свои метрики в общем реестре).